---
title: "Complete TypeScript Mastery Part 3: TypeScript Compiler & Tooling"
date: 2026-01-08 12:00:00 +0530
categories: [Programming, TypeScript, Web Development]
tags: [typescript, compiler, tooling, tsconfig, build-tools, webpack, vite, performance]
---

# Complete TypeScript Mastery Part 3: TypeScript Compiler & Tooling

## Introduction

Welcome to Part 3 of the Complete TypeScript Mastery series! In Parts 1 and 2, we explored TypeScript's fundamentals and advanced type system features. Now we'll dive deep into the TypeScript compiler, tooling ecosystem, and build configurations that power production applications.

Understanding the compiler and tooling is crucial for:
- Optimizing build performance
- Configuring projects correctly
- Debugging compilation issues
- Integrating with build tools
- Setting up monorepos
- Deploying TypeScript applications

In this part, we'll cover:
- TypeScript compiler architecture and internals
- Comprehensive tsconfig.json configuration
- Module systems and resolution strategies
- Project references and monorepos
- Integration with build tools (Webpack, Vite, esbuild)
- Performance optimization techniques
- Debugging and troubleshooting
- Production deployment strategies

By the end of this part, you'll have expert-level knowledge of TypeScript's compilation process and tooling ecosystem, enabling you to configure and optimize any TypeScript project.

---

## 3.1 TypeScript Compiler Architecture

Understanding how the TypeScript compiler works helps you write better code and debug issues effectively.

### Compiler Pipeline Overview

The TypeScript compiler (`tsc`) processes code through several distinct phases:

```
Source Code (.ts)
    ↓
Scanner (Lexical Analysis)
    ↓
Parser (Syntactic Analysis)
    ↓
Binder (Symbol Resolution)
    ↓
Checker (Type Checking)
    ↓
Emitter (Code Generation)
    ↓
Output (.js, .d.ts, .map)
```

### Scanner Phase

The scanner converts source code into tokens:

```typescript
// Source code
const greeting: string = "Hello";

// Tokens generated by scanner
[
  { kind: SyntaxKind.ConstKeyword, text: "const" },
  { kind: SyntaxKind.Identifier, text: "greeting" },
  { kind: SyntaxKind.ColonToken, text: ":" },
  { kind: SyntaxKind.Identifier, text: "string" },
  { kind: SyntaxKind.EqualsToken, text: "=" },
  { kind: SyntaxKind.StringLiteral, text: "\"Hello\"" },
  { kind: SyntaxKind.SemicolonToken, text: ";" }
]
```

**Scanner responsibilities:**
- Tokenization: Breaking source into tokens
- Whitespace handling: Ignoring spaces, tabs, newlines
- Comment processing: Extracting JSDoc comments
- String interpolation: Parsing template literals

### Parser Phase

The parser builds an Abstract Syntax Tree (AST) from tokens:

```typescript
// Source code
function add(a: number, b: number): number {
  return a + b;
}

// Simplified AST structure
{
  kind: SyntaxKind.FunctionDeclaration,
  name: { text: "add" },
  parameters: [
    {
      name: { text: "a" },
      type: { kind: SyntaxKind.NumberKeyword }
    },
    {
      name: { text: "b" },
      type: { kind: SyntaxKind.NumberKeyword }
    }
  ],
  type: { kind: SyntaxKind.NumberKeyword },
  body: {
    kind: SyntaxKind.Block,
    statements: [
      {
        kind: SyntaxKind.ReturnStatement,
        expression: {
          kind: SyntaxKind.BinaryExpression,
          left: { text: "a" },
          operator: SyntaxKind.PlusToken,
          right: { text: "b" }
        }
      }
    ]
  }
}
```

**Parser responsibilities:**
- AST construction: Building tree structure
- Syntax validation: Checking grammar rules
- Error recovery: Continuing after syntax errors
- JSDoc parsing: Extracting type information

### Binder Phase

The binder creates symbols and resolves scope:

```typescript
// Source code
let x = 10;
function foo() {
  let x = 20;  // Different symbol
  console.log(x);
}

// Symbol table created by binder
{
  moduleScope: {
    x: Symbol { name: "x", declarations: [...] },
    foo: Symbol { name: "foo", declarations: [...] }
  },
  fooScope: {
    parent: moduleScope,
    x: Symbol { name: "x", declarations: [...] }  // Local x
  }
}
```

**Binder responsibilities:**
- Symbol creation: Creating symbols for identifiers
- Scope construction: Building scope hierarchy
- Declaration merging: Merging interface declarations
- Module resolution: Resolving import/export

### Checker Phase

The checker performs type checking and type inference:

```typescript
// Source code
function greet(name: string): string {
  return "Hello, " + name;
}

greet(123);  // Type error detected here

// Checker process
1. Infer parameter type: name is string
2. Infer return type: string + string = string
3. Check return type matches annotation: ✓
4. Check function call: greet(123)
   - Expected: string
   - Actual: number
   - Error: Argument of type 'number' is not assignable to parameter of type 'string'
```

**Checker responsibilities:**
- Type inference: Determining types from context
- Type checking: Validating type compatibility
- Flow analysis: Control flow type narrowing
- Error reporting: Generating diagnostic messages

### Emitter Phase

The emitter generates JavaScript and declaration files:

```typescript
// Source code (TypeScript)
interface User {
  name: string;
  age: number;
}

const user: User = {
  name: "Alice",
  age: 30
};

function greet(user: User): string {
  return `Hello, ${user.name}`;
}

// Emitted JavaScript (.js)
"use strict";
const user = {
    name: "Alice",
    age: 30
};
function greet(user) {
    return `Hello, ${user.name}`;
}

// Emitted Declaration (.d.ts)
interface User {
    name: string;
    age: number;
}
declare const user: User;
declare function greet(user: User): string;

// Source Map (.js.map)
{
  "version": 3,
  "file": "example.js",
  "sourceRoot": "",
  "sources": ["example.ts"],
  "mappings": ";;AAMA,MAAM,IAAI,GAAe..."
}
```

**Emitter responsibilities:**
- JavaScript generation: Converting TypeScript to JavaScript
- Declaration files: Generating .d.ts files
- Source maps: Creating debugging mappings
- Target transformation: Adapting to ES version

### Compilation Modes

TypeScript supports different compilation modes:

#### Watch Mode

```bash
# Watch for file changes and recompile
tsc --watch

# or in tsconfig.json
tsc -w
```

**How watch mode works:**
1. Initial compilation of all files
2. Monitor file system for changes
3. Incremental compilation on change
4. Cache AST and type information
5. Only recompile changed files and dependents

#### Incremental Compilation

```json
// tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": ".tsbuildinfo"
  }
}
```

**Benefits:**
- Stores compilation state in `.tsbuildinfo`
- Faster subsequent compilations
- Skips unchanged files
- Essential for large projects

#### Project References

```json
// Base project tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "declaration": true
  },
  "references": []
}

// Dependent project tsconfig.json
{
  "compilerOptions": {
    "composite": true
  },
  "references": [
    { "path": "../base" }
  ]
}
```

**Benefits:**
- Parallel compilation
- Better IDE performance
- Enforced project boundaries
- Faster incremental builds

### Compiler API

Access compiler functionality programmatically:

```typescript
import * as ts from "typescript";

// Parse source file
const sourceCode = `
  function greet(name: string): string {
    return "Hello, " + name;
  }
`;

const sourceFile = ts.createSourceFile(
  "example.ts",
  sourceCode,
  ts.ScriptTarget.Latest,
  true
);

// Visit all nodes
function visit(node: ts.Node) {
  console.log(ts.SyntaxKind[node.kind]);
  ts.forEachChild(node, visit);
}

visit(sourceFile);

// Type checking
const program = ts.createProgram({
  rootNames: ["example.ts"],
  options: {
    target: ts.ScriptTarget.ES2020,
    module: ts.ModuleKind.CommonJS
  }
});

const checker = program.getTypeChecker();
const diagnostics = ts.getPreEmitDiagnostics(program);

diagnostics.forEach(diagnostic => {
  const message = ts.flattenDiagnosticMessageText(
    diagnostic.messageText,
    "\n"
  );
  console.log(message);
});

// Emit files
const emitResult = program.emit();
```

**Common Compiler API Use Cases:**
- Custom linters and analyzers
- Code transformation tools
- Documentation generators
- Type extraction utilities
- Custom build tools

### Compiler Performance

Understanding performance characteristics:

```typescript
// Factors affecting compilation speed

// 1. Project size
// - More files = slower compilation
// - Solution: Project references, incremental compilation

// 2. Type complexity
// - Complex generic types slow down checker
// - Solution: Simplify types, avoid deep recursion

// 3. Declaration file generation
// - Generating .d.ts files adds overhead
// - Solution: Only generate when needed

// 4. Source maps
// - Source map generation adds time
// - Solution: Disable in production builds

// 5. Module resolution
// - Resolving many modules is expensive
// - Solution: Use path mapping, avoid deep node_modules

// Performance measurement
console.time("Compilation");
const program = ts.createProgram({
  rootNames: files,
  options: compilerOptions
});
const emitResult = program.emit();
console.timeEnd("Compilation");

// Diagnostics timing
tsc --diagnostics
// Outputs:
// Files:             250
// Lines:             50000
// Nodes:             150000
// Identifiers:       25000
// Symbols:           20000
// Types:             15000
// I/O read:          0.50s
// I/O write:         0.20s
// Parse time:        1.20s
// Bind time:         0.80s
// Check time:        3.50s
// Emit time:         0.70s
// Total time:        6.70s
```

### Frequently Asked Questions

**Q1: What's the difference between compilation and transpilation?**

**A:** Compilation converts high-level language to lower-level language (C to machine code). Transpilation converts between languages at similar abstraction levels:

```typescript
// TypeScript (source)
const greeting: string = "Hello";
function greet(name: string): string {
  return greeting + ", " + name;
}

// JavaScript (transpiled output)
const greeting = "Hello";
function greet(name) {
  return greeting + ", " + name;
}

// Key differences:
// 1. Type annotations removed (types are compile-time only)
// 2. Modern syntax downleveled if needed
// 3. No runtime type checking added
// 4. Output is readable JavaScript
```

TypeScript is technically a transpiler because it converts TypeScript to JavaScript, both high-level languages.

---

**Q2: How does incremental compilation work?**

**A:** Incremental compilation saves compilation state to speed up subsequent builds:

```json
// tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./.tsbuildinfo"
  }
}
```

**How it works:**
1. First compilation: Normal full compilation
2. `.tsbuildinfo` file created with:
   - File hashes
   - Dependency graph
   - Type information
   - Compilation metadata
3. Subsequent compilations:
   - Check file hashes
   - Only recompile changed files
   - Recompile files that depend on changed files
   - Reuse cached information for unchanged files

**Benefits:**
- 2-10x faster rebuilds
- Essential for large projects
- Works with project references

**Trade-offs:**
- Initial build still slow
- `.tsbuildinfo` file to manage
- Cache invalidation on config changes

---

**Q3: What are the different phases of the TypeScript compiler?**

**A:** Five main phases:

```
1. Scanner (Lexical Analysis)
   - Input: Source code string
   - Output: Token stream
   - Purpose: Break code into tokens

2. Parser (Syntactic Analysis)
   - Input: Token stream
   - Output: Abstract Syntax Tree (AST)
   - Purpose: Build tree structure

3. Binder (Symbol Resolution)
   - Input: AST
   - Output: Symbol table and scopes
   - Purpose: Connect references to declarations

4. Checker (Type Checking)
   - Input: AST + Symbols
   - Output: Type information + Errors
   - Purpose: Validate type correctness

5. Emitter (Code Generation)
   - Input: AST + Type info
   - Output: JavaScript + .d.ts + .map
   - Purpose: Generate output files
```

**Why this matters:**
- Understanding phases helps debug issues
- Each phase can be accessed via Compiler API
- Performance optimization targets specific phases
- Error messages indicate which phase failed

---

**Q4: Can I skip type checking for faster compilation?**

**A:** Yes, but with trade-offs:

```json
// Skip type checking
{
  "compilerOptions": {
    "noEmit": false,
    "skipLibCheck": true,    // Skip checking .d.ts files
    "transpileOnly": true     // Some tools only
  }
}
```

**Alternative approaches:**

```bash
# Use esbuild or swc for transpilation (much faster)
# Then run tsc separately for type checking
esbuild src/index.ts --outfile=dist/index.js

# Type check only (no emit)
tsc --noEmit

# Separate type checking in CI
npm run build    # Fast transpilation
npm run typecheck  # Separate type checking
```

**When to skip type checking:**
- Development hot reload (check separately)
- Production builds (check in CI first)
- Monorepo builds (check each package separately)

---

**Q5: How do source maps work?**

**A:** Source maps connect generated JavaScript back to original TypeScript:

```typescript
// example.ts (original)
const greeting: string = "Hello";
function greet(name: string): string {
  return greeting + ", " + name;
}

// example.js (generated)
const greeting = "Hello";
function greet(name) {
  return greeting + ", " + name;
}
//# sourceMappingURL=example.js.map

// example.js.map (source map)
{
  "version": 3,
  "file": "example.js",
  "sourceRoot": "",
  "sources": ["example.ts"],
  "names": [],
  "mappings": "AAAA,MAAM,QAAQ,GAAW,OAAO,CAAC;AACjC,SAAS,KAAK,CAAC,IAAY;IACzB,OAAO,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC;AAChC,CAAC"
}
```

**Benefits:**
- Debug TypeScript in browser DevTools
- Stack traces show TypeScript lines
- Breakpoints work in original code

**Configuration:**
```json
{
  "compilerOptions": {
    "sourceMap": true,           // Generate .js.map
    "inlineSourceMap": false,    // Don't inline in .js
    "inlineSources": false,      // Don't include TS source in map
    "sourceRoot": "",            // Root for source paths
    "mapRoot": ""                // Root for map files
  }
}
```

---

### Interview Questions

**Question 1: Explain how the TypeScript compiler's type checker handles type inference in complex scenarios.**

**Difficulty:** Senior

**Answer:**

The TypeScript type checker uses several strategies for type inference:

**1. Bottom-Up Inference (From Usage):**

```typescript
// Infer from initialization
let x = 5;  // Inferred as number

// Infer from return statements
function process() {
  if (Math.random() > 0.5) {
    return 42;  // number
  } else {
    return "hello";  // string
  }
  // Return type inferred as number | string
}

// Infer from array literals
let arr = [1, 2, "three"];  // (number | string)[]
```

**2. Top-Down Inference (From Context):**

```typescript
// Context from parameter type
interface User {
  name: string;
  age: number;
}

function processUsers(users: User[]) {
  // TypeScript knows user is User
  users.forEach(user => {
    console.log(user.name);  // No annotation needed
  });
}

// Context from return type
function createUser(): User {
  return {
    name: "Alice",  // TypeScript checks against User
    age: 30
  };
}
```

**3. Bidirectional Type Checking:**

```typescript
// TypeScript infers in both directions
const users: User[] = [
  { name: "Alice", age: 30 },  // Checked against User
  { name: "Bob", age: 25 }
];

// Generic type inference
function identity<T>(value: T): T {
  return value;
}

// T inferred from argument
const result = identity("hello");  // T = string

// T inferred from expected return type
const user: User = identity({ name: "Alice", age: 30 });  // T = User
```

**4. Control Flow Analysis:**

```typescript
function process(value: string | number | null) {
  // Type is string | number | null
  
  if (value === null) {
    // Type narrowed to null
    return;
  }
  
  // Type narrowed to string | number
  
  if (typeof value === "string") {
    // Type narrowed to string
    console.log(value.toUpperCase());
  } else {
    // Type narrowed to number
    console.log(value.toFixed(2));
  }
}
```

**5. Generic Inference with Constraints:**

```typescript
// Infer within constraints
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Alice", age: 30 };
const name = getProperty(user, "name");  
// T inferred as { name: string; age: number }
// K inferred as "name"
// Return type: string

// Multiple type parameters
function merge<T, U>(a: T, b: U): T & U {
  return { ...a, ...b };
}

const result = merge({ x: 1 }, { y: 2 });
// T = { x: number }
// U = { y: number }
// Result type: { x: number; y: number }
```

**6. Recursive Type Inference:**

```typescript
// Deep inference through recursion
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object
    ? DeepReadonly<T[P]>
    : T[P];
};

interface Nested {
  a: {
    b: {
      c: string;
    };
  };
}

const nested: DeepReadonly<Nested> = {
  a: {
    b: {
      c: "hello"
    }
  }
};

// TypeScript recursively infers all levels as readonly
```

**Inference Limitations:**

```typescript
// TypeScript can't always infer correctly

// 1. Too many possibilities
function ambiguous<T>(a: T, b: T): T {
  return Math.random() > 0.5 ? a : b;
}

ambiguous(1, "hello");  
// T inferred as string | number (best common type)

// 2. Insufficient context
function noContext<T>(): T {
  return {} as T;  // Can't infer T
}

// Must specify explicitly
const value = noContext<User>();

// 3. Circular references
interface Circular {
  prop: Circular;
}

// TypeScript has depth limits for inference
```

**Optimization Tips:**

```typescript
// Help the compiler with explicit types
function process<T extends { id: string }>(items: T[]): Map<string, T> {
  // Explicit constraint helps inference
  return new Map(items.map(item => [item.id, item]));
}

// Use type assertions sparingly
const user = getUserData() as User;  // Override inference

// Leverage const assertions
const config = {
  host: "localhost",
  port: 3000
} as const;
// Inferred as: { readonly host: "localhost"; readonly port: 3000 }
```

**Why This Matters:**
- Understanding inference helps write more concise code
- Reduces need for explicit type annotations
- Critical for debugging type errors
- Affects compilation performance

**Follow-up Questions:**
- How does TypeScript handle circular type dependencies?
- What's the difference between structural and nominal inference?
- How do you debug complex inference issues?

---

**Question 2: How would you optimize TypeScript compilation for a large monorepo?**

**Difficulty:** Senior

**Answer:**

Optimizing TypeScript compilation in large monorepos requires multiple strategies:

**1. Project References:**

```json
// packages/core/tsconfig.json
{
  "compilerOptions": {
    "composite": true,        // Enable project references
    "declaration": true,      // Required for references
    "declarationMap": true,   // For IDE navigation
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}

// packages/ui/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "declaration": true
  },
  "references": [
    { "path": "../core" }     // Reference core package
  ]
}

// Root tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/ui" },
    { "path": "./packages/api" }
  ]
}
```

**Benefits:**
- Parallel compilation of independent packages
- Incremental builds per package
- Better IDE performance
- Enforced dependencies

**2. Incremental Compilation:**

```json
// tsconfig.json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./dist/.tsbuildinfo"
  }
}
```

**3. Build Mode:**

```bash
# Build all projects and dependencies
tsc --build

# Build with cache
tsc --build --incremental

# Clean build
tsc --build --clean

# Force rebuild
tsc --build --force

# Verbose output
tsc --build --verbose

# Watch mode
tsc --build --watch
```

**4. Optimize Type Checking:**

```json
{
  "compilerOptions": {
    // Skip checking node_modules
    "skipLibCheck": true,
    
    // Skip default library checking
    "skipDefaultLibCheck": true,
    
    // Faster for large projects
    "incremental": true,
    
    // Disable unused checks in development
    "noUnusedLocals": false,      // Enable in CI only
    "noUnusedParameters": false    // Enable in CI only
  }
}
```

**5. Module Resolution Optimization:**

```json
{
  "compilerOptions": {
    // Faster module resolution
    "moduleResolution": "bundler",  // or "node16"
    
    // Path mapping reduces resolution time
    "baseUrl": ".",
    "paths": {
      "@core/*": ["packages/core/src/*"],
      "@ui/*": ["packages/ui/src/*"],
      "@api/*": ["packages/api/src/*"]
    }
  }
}
```

**6. Separate Type Checking:**

```json
// package.json
{
  "scripts": {
    // Fast transpilation (no type checking)
    "build": "swc src -d dist",
    
    // Type checking only (no emit)
    "typecheck": "tsc --noEmit",
    
    // Run in parallel
    "build:prod": "npm run build && npm run typecheck",
    
    // CI: Fail on type errors
    "ci": "npm run typecheck && npm run build"
  }
}
```

**7. Use Faster Transpilers:**

```bash
# esbuild (very fast, no type checking)
esbuild src/index.ts --bundle --outfile=dist/index.js

# swc (very fast, no type checking)
swc src -d dist

# Type check separately
tsc --noEmit
```

**8. Workspace Configuration:**

```json
// pnpm-workspace.yaml or lerna.json
{
  "packages": [
    "packages/*"
  ]
}

// package.json (root)
{
  "scripts": {
    "build": "turbo run build",
    "typecheck": "turbo run typecheck"
  }
}
```

**9. Caching Strategies:**

```json
// turbo.json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"],
      "cache": true
    },
    "typecheck": {
      "cache": true,
      "outputs": []
    }
  }
}
```

**10. Development vs Production:**

```json
// tsconfig.dev.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "skipLibCheck": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "incremental": true
  }
}

// tsconfig.prod.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "skipLibCheck": false,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "sourceMap": false,
    "removeComments": true
  }
}
```

**Measurement and Monitoring:**

```bash
# Measure compilation time
tsc --diagnostics

# Profile compilation
tsc --extendedDiagnostics

# Trace resolution
tsc --traceResolution

# Generate dependency graph
tsc --generateTrace trace
```

**Results:**

```
Before optimization:
- Full build: 5 minutes
- Incremental: 2 minutes
- Type checking: 1 minute

After optimization:
- Full build: 1 minute
- Incremental: 10 seconds
- Type checking: 20 seconds
```

**Why This Matters:**
- Developer productivity improves dramatically
- CI/CD pipelines run faster
- Hot reload becomes feasible
- Essential for large teams
- Reduces infrastructure costs

**Follow-up Questions:**
- How do you handle circular dependencies in project references?
- What's the trade-off between skipLibCheck and type safety?
- How do you debug slow compilation?

---

### Key Takeaways

- TypeScript compiler has 5 phases: Scanner, Parser, Binder, Checker, Emitter
- Each phase transforms input (source → tokens → AST → symbols → types → output)
- Understanding phases helps debug compilation issues
- Incremental compilation dramatically speeds up rebuilds
- Project references enable parallel compilation and better organization
- Compiler API enables programmatic access to all phases
- Performance optimization targets specific bottlenecks
- Source maps enable debugging TypeScript in production
- Watch mode is essential for development workflow
- Separating type checking from transpilation improves build speed

---

## 3.2 tsconfig.json Deep Dive

The `tsconfig.json` file is the heart of any TypeScript project, controlling all compilation behavior.

### Basic Structure

```json
{
  "compilerOptions": {
    // Compiler settings
  },
  "include": [
    // Files to include
  ],
  "exclude": [
    // Files to exclude
  ],
  "files": [
    // Explicit file list
  ],
  "extends": "./base-config.json",
  "references": [
    // Project references
  ]
}
```

### Compiler Options: Target and Module

```json
{
  "compilerOptions": {
    // JavaScript version to emit
    "target": "ES2020",
    // Options: ES3, ES5, ES2015, ES2016, ES2017, ES2018, ES2019, ES2020, ES2021, ES2022, ESNext
    
    // Module system
    "module": "CommonJS",
    // Options: CommonJS, AMD, UMD, System, ES2015, ES2020, ESNext, Node16, NodeNext
    
    // Module resolution strategy
    "moduleResolution": "node",
    // Options: classic, node, node16, nodenext, bundler
    
    // Libraries to include
    "lib": ["ES2020", "DOM"],
    // Options: ES5, ES6, ES2015, ES2016, ES2017, ES2018, ES2019, ES2020, ES2021, DOM, WebWorker, etc.
  }
}
```

**Target Examples:**

```typescript
// Source TypeScript
const greeting = "Hello";
async function fetchData() {
  const response = await fetch("/api/data");
  return response.json();
}

// target: "ES2020" (modern)
const greeting = "Hello";
async function fetchData() {
  const response = await fetch("/api/data");
  return response.json();
}

// target: "ES5" (downleveled)
var greeting = "Hello";
function fetchData() {
  return __awaiter(this, void 0, void 0, function() {
    var response;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, fetch("/api/data")];
        case 1:
          response = _a.sent();
          return [2, response.json()];
      }
    });
  });
}
```

### Strict Type Checking Options

```json
{
  "compilerOptions": {
    // Enable all strict checks
    "strict": true,
    
    // Individual strict flags (enabled by strict: true)
    "noImplicitAny": true,              // Error on implicit 'any'
    "strictNullChecks": true,           // null/undefined are not assignable to other types
    "strictFunctionTypes": true,        // Stricter function type checks
    "strictBindCallApply": true,        // Check bind, call, apply
    "strictPropertyInitialization": true, // Class properties must be initialized
    "noImplicitThis": true,             // Error on implicit 'any' for this
    "alwaysStrict": true,               // Emit 'use strict'
    
    // Additional checks
    "noUnusedLocals": true,             // Error on unused local variables
    "noUnusedParameters": true,         // Error on unused parameters
    "noImplicitReturns": true,          // Error if not all code paths return
    "noFallthroughCasesInSwitch": true, // Error on fallthrough cases
    "noUncheckedIndexedAccess": true,   // Add undefined to index signatures
    "noImplicitOverride": true,         // Require 'override' keyword
    "noPropertyAccessFromIndexSignature": true, // Use bracket access for index signatures
    "exactOptionalPropertyTypes": true   // Don't allow undefined for optional properties
  }
}
```

**Impact of Strict Flags:**

```typescript
// noImplicitAny
function process(value) {  // ❌ Error: Parameter 'value' implicitly has an 'any' type
  return value;
}

function process(value: unknown) {  // ✅ OK
  return value;
}

// strictNullChecks
let name: string = null;  // ❌ Error: Type 'null' is not assignable to type 'string'
let name: string | null = null;  // ✅ OK

// strictFunctionTypes
interface Animal { name: string; }
interface Dog extends Animal { breed: string; }

type AnimalHandler = (animal: Animal) => void;
type DogHandler = (dog: Dog) => void;

const handleAnimal: AnimalHandler = (animal) => { };
const handleDog: DogHandler = handleAnimal;  // ✅ OK: Contravariant

const handleOnlyDog: DogHandler = (dog) => { console.log(dog.breed); };
const anyAnimal: AnimalHandler = handleOnlyDog;  // ❌ Error with strictFunctionTypes

// noImplicitReturns
function getValue(flag: boolean): string {
  if (flag) {
    return "yes";
  }
  // ❌ Error: Not all code paths return a value
}

// noUncheckedIndexedAccess
interface Users {
  [key: string]: User;
}

const users: Users = {};
const user = users["123"];  
// Without flag: Type is User
// With flag: Type is User | undefined

// exactOptionalPropertyTypes
interface Config {
  port?: number;
}

const config: Config = {
  port: undefined  // ❌ Error with exactOptionalPropertyTypes
};

const config2: Config = {};  // ✅ OK: Property absent
```

### Module Resolution

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"]
    },
    "rootDirs": ["src", "generated"],
    "typeRoots": ["./types", "./node_modules/@types"],
    "types": ["node", "jest"],
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  }
}
```

**Path Mapping Example:**

```typescript
// Without path mapping
import { Button } from "../../components/Button";
import { formatDate } from "../../../utils/date";

// With path mapping
import { Button } from "@components/Button";
import { formatDate } from "@utils/date";
```

### Output Configuration

```json
{
  "compilerOptions": {
    // Output directory
    "outDir": "./dist",
    
    // Source directory
    "rootDir": "./src",
    
    // Generate declaration files
    "declaration": true,
    "declarationDir": "./types",
    "declarationMap": true,
    
    // Source maps
    "sourceMap": true,
    "inlineSourceMap": false,
    "inlineSources": false,
    
    // Remove comments
    "removeComments": true,
    
    // Import helpers from tslib
    "importHelpers": true,
    
    // Downlevel iteration
    "downlevelIteration": true,
    
    // Emit decorators metadata
    "emitDecoratorMetadata": true,
    
    // Preserve const enums
    "preserveConstEnums": false,
    
    // No emit on error
    "noEmitOnError": true
  }
}
```

### JSX Configuration

```json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    // Options: preserve, react, react-jsx, react-jsxdev, react-native
    
    "jsxFactory": "React.createElement",
    "jsxFragmentFactory": "React.Fragment",
    "jsxImportSource": "react"
  }
}
```

**JSX Modes:**

```typescript
// Source JSX
const element = <div>Hello</div>;

// jsx: "preserve" (output .jsx)
const element = <div>Hello</div>;

// jsx: "react" (output .js)
const element = React.createElement("div", null, "Hello");

// jsx: "react-jsx" (output .js, React 17+)
import { jsx as _jsx } from "react/jsx-runtime";
const element = _jsx("div", { children: "Hello" });

// jsx: "react-jsxdev" (development mode)
import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
const element = _jsxDEV("div", { children: "Hello" }, void 0, false, {}, this);
```

### Interop and Compatibility

```json
{
  "compilerOptions": {
    // Allow importing CommonJS modules
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    
    // Allow JavaScript files
    "allowJs": true,
    "checkJs": false,
    
    // Force consistent casing
    "forceConsistentCasingInFileNames": true,
    
    // Isolated modules
    "isolatedModules": true,
    
    // Resolve package.json exports
    "resolvePackageJsonExports": true,
    "resolvePackageJsonImports": true
  }
}
```

### Advanced Options

```json
{
  "compilerOptions": {
    // Experimental features
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    
    // Performance
    "incremental": true,
    "tsBuildInfoFile": "./.tsbuildinfo",
    "assumeChangesOnlyAffectDirectDependencies": false,
    
    // Debugging
    "traceResolution": false,
    "listFiles": false,
    "explainFiles": false,
    "extendedDiagnostics": false,
    
    // Plugins
    "plugins": [
      {
        "name": "typescript-plugin-css-modules"
      }
    ]
  }
}
```

### Include, Exclude, Files

```json
{
  "include": [
    "src/**/*",           // All files in src
    "tests/**/*"          // All files in tests
  ],
  "exclude": [
    "node_modules",       // Excluded by default
    "**/*.spec.ts",       // Exclude test files
    "dist",               // Output directory
    "build",
    "coverage"
  ],
  "files": [
    "src/index.ts",       // Explicit file list
    "src/types.d.ts"
  ]
}
```

**Rules:**
1. `files` takes highest priority
2. `include` specifies which files to include
3. `exclude` overrides `include`
4. `node_modules` excluded by default unless in `files`

### Configuration Inheritance

```json
// tsconfig.base.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "strict": true,
    "esModuleInterop": true
  }
}

// tsconfig.json (development)
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": true,
    "noUnusedLocals": false
  },
  "include": ["src/**/*"]
}

// tsconfig.prod.json (production)
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false,
    "removeComments": true,
    "noUnusedLocals": true
  },
  "include": ["src/**/*"],
  "exclude": ["**/*.test.ts"]
}
```

### Project References

```json
// packages/core/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"]
}

// packages/ui/tsconfig.json
{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "outDir": "./dist"
  },
  "references": [
    { "path": "../core" }
  ],
  "include": ["src/**/*"]
}

// Root tsconfig.json
{
  "files": [],
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/ui" }
  ]
}
```

### Environment-Specific Configurations

```json
// tsconfig.json (base)
{
  "compilerOptions": {
    "target": "ES2020",
    "strict": true
  }
}

// tsconfig.node.json (Node.js)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "CommonJS",
    "lib": ["ES2020"],
    "types": ["node"]
  }
}

// tsconfig.browser.json (Browser)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "ES2020",
    "lib": ["ES2020", "DOM"],
    "moduleResolution": "bundler"
  }
}

// tsconfig.test.json (Testing)
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["jest", "node"],
    "noUnusedLocals": false
  },
  "include": ["src/**/*", "tests/**/*"]
}
```

### Common Configurations

#### React Application

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "bundler",
    
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

#### Node.js Application

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    
    "outDir": "./dist",
    "rootDir": "./src",
    
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    
    "types": ["node"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

#### Library Package

```json
{
  "compilerOptions": {
    "target": "ES2015",
    "module": "ES2015",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    
    "outDir": "./dist",
    "rootDir": "./src",
    
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    
    "removeComments": false,
    "importHelpers": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

### Frequently Asked Questions

**Q1: What's the difference between `target` and `lib`?**

**A:** `target` determines the JavaScript version emitted, `lib` determines which built-in APIs TypeScript recognizes:

```json
{
  "compilerOptions": {
    // JavaScript version to emit
    "target": "ES5",
    
    // APIs available in code
    "lib": ["ES2020", "DOM"]
  }
}
```

```typescript
// With lib: ["ES2020", "DOM"]
// TypeScript knows about Promise, fetch, etc.
async function getData() {
  const response = await fetch("/api");  // ✅ OK: fetch is in DOM lib
  return response.json();
}

// Emits ES5 code (with helpers)
function getData() {
  return __awaiter(this, void 0, void 0, function() {
    // ... ES5 code
  });
}
```

**Use case:**
- `target: "ES5"` with `lib: ["ES2020", "DOM"]` - Modern APIs, old browser support (requires polyfills)
- `target: "ES2020"` with `lib: ["ES2020"]` - Modern everything, no polyfills needed

---

**Q2: Should I use `CommonJS` or `ES2020` for the module option?**

**A:** Depends on your target environment:

```json
// Node.js application (before Node 14)
{
  "compilerOptions": {
    "module": "CommonJS"  // require/module.exports
  }
}

// Modern Node.js (14+) with "type": "module"
{
  "compilerOptions": {
    "module": "ES2020"  // import/export
  }
}

// Library (let bundlers handle it)
{
  "compilerOptions": {
    "module": "ES2015"  // Tree-shakeable
  }
}

// Browser with bundler
{
  "compilerOptions": {
    "module": "ESNext"  // Latest features
  }
}
```

**Decision tree:**
- Node.js without ESM → `CommonJS`
- Node.js with ESM → `Node16` or `NodeNext`
- Browser with bundler → `ESNext`
- Library → `ES2015` or `ES2020`

---

**Q3: What does `isolatedModules` do and when should I enable it?**

**A:** `isolatedModules` ensures each file can be transpiled independently:

```typescript
// ❌ Error with isolatedModules
export { User } from "./types";  // Re-export type only

// ✅ OK
export type { User } from "./types";  // Explicit type re-export
export { type User } from "./types";  // Alternative syntax

// ❌ Error with isolatedModules
const enum Direction {
  Up,
  Down
}

// ✅ OK
enum Direction {
  Up,
  Down
}
```

**Enable when:**
- Using Babel, esbuild, swc (they transpile per-file)
- Working with certain bundlers
- Want faster compilation

**Restrictions:**
- No const enums (inlined across files)
- Must use `type` keyword for type-only imports/exports
- Some declaration emit patterns not allowed

---

**Q4: What's the difference between `paths` and `baseUrl`?**

**A:** `baseUrl` sets the root for relative imports, `paths` creates aliases:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}
```

```typescript
// Without paths
import { Button } from "../../components/Button";

// With paths
import { Button } from "@components/Button";

// baseUrl allows this
import { helper } from "src/utils/helper";

// Instead of
import { helper } from "./src/utils/helper";
```

**Important:** Most bundlers need separate configuration:

```javascript
// webpack.config.js
module.exports = {
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
      '@components': path.resolve(__dirname, 'src/components')
    }
  }
};

// vite.config.js
export default {
  resolve: {
    alias: {
      '@': '/src',
      '@components': '/src/components'
    }
  }
};
```

---

**Q5: When should I use `skipLibCheck`?**

**A:** `skipLibCheck` skips type checking of declaration files (.d.ts):

```json
{
  "compilerOptions": {
    "skipLibCheck": true
  }
}
```

**Pros:**
- Faster compilation (skip node_modules types)
- Avoid errors in third-party types
- Useful in large projects

**Cons:**
- Might miss real type errors
- Less type safety
- Could hide breaking changes

**Recommendation:**
- **Enable** in development for speed
- **Disable** in CI to catch issues
- **Enable** if encountering third-party type errors you can't fix

```json
// tsconfig.dev.json
{
  "compilerOptions": {
    "skipLibCheck": true  // Fast development
  }
}

// tsconfig.prod.json
{
  "compilerOptions": {
    "skipLibCheck": false  // Full checking
  }
}
```

---

### Interview Questions

**Question 1: Design a tsconfig.json for a monorepo with shared packages.**

**Difficulty:** Senior

**Answer:**

A well-structured monorepo requires multiple coordinated tsconfig files:

```
monorepo/
├── tsconfig.base.json           # Shared settings
├── tsconfig.json                # Root references
├── packages/
│   ├── core/
│   │   ├── tsconfig.json       # Core package
│   │   └── src/
│   ├── ui/
│   │   ├── tsconfig.json       # UI package (depends on core)
│   │   └── src/
│   └── api/
│       ├── tsconfig.json        # API package (depends on core)
│       └── src/
└── apps/
    └── web/
        ├── tsconfig.json        # Web app (depends on ui, api)
        └── src/
```

**Base Configuration:**

```json
// tsconfig.base.json
{
  "compilerOptions": {
    // Modern JavaScript
    "target": "ES2020",
    "lib": ["ES2020"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    
    // Strict type checking
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    
    // Module resolution
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    
    // Project references
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    
    // Performance
    "incremental": true,
    
    // Path mapping
    "baseUrl": ".",
    "paths": {
      "@core/*": ["packages/core/src/*"],
      "@ui/*": ["packages/ui/src/*"],
      "@api/*": ["packages/api/src/*"]
    }
  }
}
```

**Core Package:**

```json
// packages/core/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "tsBuildInfoFile": "./dist/.tsbuildinfo"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

**UI Package (depends on Core):**

```json
// packages/ui/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "jsx": "react-jsx",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "tsBuildInfoFile": "./dist/.tsbuildinfo"
  },
  "references": [
    { "path": "../core" }
  ],
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

**API Package (depends on Core):**

```json
// packages/api/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "module": "CommonJS",
    "types": ["node"],
    "tsBuildInfoFile": "./dist/.tsbuildinfo"
  },
  "references": [
    { "path": "../core" }
  ],
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

**Web App (depends on UI and API):**

```json
// apps/web/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "jsx": "react-jsx",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "isolatedModules": true,
    "noEmit": true,  // Bundler handles emit
    "tsBuildInfoFile": "./.tsbuildinfo"
  },
  "references": [
    { "path": "../../packages/core" },
    { "path": "../../packages/ui" },
    { "path": "../../packages/api" }
  ],
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

**Root Configuration:**

```json
// tsconfig.json (root)
{
  "files": [],
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/ui" },
    { "path": "./packages/api" },
    { "path": "./apps/web" }
  ]
}
```

**Package.json Scripts:**

```json
{
  "scripts": {
    "build": "tsc --build",
    "build:watch": "tsc --build --watch",
    "build:clean": "tsc --build --clean",
    "build:force": "tsc --build --force",
    "build:verbose": "tsc --build --verbose",
    
    "typecheck": "tsc --build --noEmit",
    "typecheck:watch": "tsc --build --noEmit --watch"
  }
}
```

**Build Order:**

```
1. packages/core (no dependencies)
2. packages/ui (depends on core)
   packages/api (depends on core)
3. apps/web (depends on ui, api)
```

**Benefits:**

1. **Parallel Compilation:**
   - UI and API can build simultaneously
   - Faster overall build time

2. **Incremental Builds:**
   - Only rebuild changed packages
   - Cached builds in `.tsbuildinfo`

3. **Type Safety:**
   - References ensure type consistency
   - Catch cross-package type errors

4. **IDE Performance:**
   - Better IntelliSense
   - Faster navigation
   - Project boundaries

5. **Clear Dependencies:**
   - References make dependencies explicit
   - Prevent circular dependencies

**Testing Configuration:**

```json
// packages/core/tsconfig.test.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "types": ["jest", "node"],
    "noUnusedLocals": false,
    "noUnusedParameters": false
  },
  "include": ["src/**/*", "**/*.test.ts"]
}
```

**Production Configuration:**

```json
// tsconfig.prod.json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "sourceMap": false,
    "removeComments": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "declaration": false  // Not needed in production
  }
}
```

**Why This Matters:**
- Scales to large codebases
- Enables fast incremental builds
- Enforces architectural boundaries
- Improves developer experience
- Essential for teams

**Follow-up Questions:**
- How do you handle circular dependencies?
- What's the trade-off between composite and regular projects?
- How do you optimize build times further?

---

### Key Takeaways

- `tsconfig.json` controls all compilation behavior
- `strict: true` enables comprehensive type checking
- `target` sets JavaScript version, `lib` sets available APIs
- Path mapping improves import ergonomics
- Project references enable monorepo organization
- Different environments need different configurations
- Inheritance via `extends` reduces duplication
- `skipLibCheck` trades safety for speed
- `isolatedModules` enables per-file transpilation
- Understanding configuration is essential for optimization

---

## 3.3 Module Systems and Resolution

### Module Formats

TypeScript supports multiple module systems:

```typescript
// ES Modules (ESM)
import { User } from "./types";
export const createUser = () => {};
export default User;

// CommonJS
const { User } = require("./types");
module.exports = { createUser: () => {} };
exports.createUser = () => {};

// AMD (legacy)
define(["./types"], function(types) {
  return { createUser: () => {} };
});

// UMD (Universal)
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports'], factory);
  } else if (typeof exports === 'object') {
    factory(exports);
  } else {
    factory((root.myModule = {}));
  }
}(this, function (exports) {
  exports.createUser = () => {};
}));
```

**Module Resolution Strategies:**

```json
{
  "compilerOptions": {
    "moduleResolution": "node",
    // Options: classic, node, node16, nodenext, bundler
  }
}
```

### Working with Different Module Systems

```typescript
// ESM with default imports
import React from "react";  // Default import
import { useState } from "react";  // Named import
import * as ReactDOM from "react-dom";  // Namespace import

// CommonJS interop
const express = require("express");  // ❌ In strict ESM

// With esModuleInterop
import express from "express";  // ✅ Works

// Dynamic imports
const module = await import("./dynamic-module");

// Type-only imports
import type { User } from "./types";
import { type Config } from "./config";
```

---

## 3.4 Build Tool Integration

### Webpack Integration

```javascript
// webpack.config.js
module.exports = {
  entry: './src/index.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
};
```

### Vite Integration

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': '/src',
    },
  },
  build: {
    sourcemap: true,
  },
});
```

### esbuild Integration

```javascript
require('esbuild').build({
  entryPoints: ['src/index.ts'],
  bundle: true,
  outfile: 'dist/index.js',
  platform: 'node',
  target: 'node14',
  sourcemap: true,
});
```

---

## 3.5 Performance Optimization

### Compilation Speed Optimization

```json
{
  "compilerOptions": {
    // Fast compilation
    "skipLibCheck": true,
    "incremental": true,
    "isolatedModules": true,
    
    // Disable unused checks in dev
    "noUnusedLocals": false,
    "noUnusedParameters": false
  }
}
```

### Bundle Size Optimization

```json
{
  "compilerOptions": {
    "target": "ES2020",          // Modern target = smaller output
    "module": "ES2020",           // Enable tree shaking
    "removeComments": true,       // Remove comments
    "importHelpers": true,        // Use tslib helpers
    "downlevelIteration": false   // Reduce bundle size
  }
}
```

**Tree Shaking:**

```typescript
// utils.ts
export function used() { }
export function unused() { }  // Will be removed

// index.ts
import { used } from './utils';
used();  // Only 'used' is bundled
```

---

## 3.6 Testing TypeScript

### Jest Configuration

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
  ],
};
```

```typescript
// example.test.ts
import { add } from './math';

describe('add function', () => {
  it('adds two numbers', () => {
    expect(add(2, 3)).toBe(5);
  });
  
  it('handles negative numbers', () => {
    expect(add(-1, 1)).toBe(0);
  });
});
```

### Type Testing

```typescript
// Type assertions for testing
import { expectType, expectError } from 'tsd';

// Test that type is correct
expectType<string>(getValue());

// Test that code produces error
expectError(processValue(123));  // Should error

// Test assignability
expectType<User>(createUser());
```

---

## 3.7 Production Deployment

### Building for Production

```json
// tsconfig.prod.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "sourceMap": false,
    "removeComments": true,
    "declaration": false,
    "noUnusedLocals": true,
    "noUnusedParameters": true
  },
  "exclude": ["**/*.test.ts", "**/*.spec.ts"]
}
```

```json
// package.json
{
  "scripts": {
    "build": "tsc -p tsconfig.prod.json",
    "build:watch": "tsc -p tsconfig.prod.json --watch",
    "typecheck": "tsc --noEmit",
    "clean": "rm -rf dist"
  }
}
```

### Docker Integration

```dockerfile
# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY tsconfig.json ./
COPY src ./src
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY package*.json ./
RUN npm ci --production

CMD ["node", "dist/index.js"]
```

### Environment Variables

```typescript
// env.d.ts
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      NODE_ENV: 'development' | 'production' | 'test';
      API_URL: string;
      DATABASE_URL: string;
      PORT: string;
    }
  }
}

export {};

// Using environment variables
const apiUrl: string = process.env.API_URL;
const port: number = parseInt(process.env.PORT, 10);
```

---

## 3.8 Troubleshooting and Debugging

### Common Issues

**Issue 1: Module Resolution Errors**

```typescript
// Error: Cannot find module '@/components/Button'

// Solution 1: Check paths in tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}

// Solution 2: Check bundler configuration
// webpack.config.js
resolve: {
  alias: {
    '@': path.resolve(__dirname, 'src')
  }
}
```

**Issue 2: Type Declaration Errors**

```typescript
// Error: Could not find declaration file for module 'my-library'

// Solution 1: Install types
npm install --save-dev @types/my-library

// Solution 2: Create declaration file
// types/my-library.d.ts
declare module 'my-library' {
  export function doSomething(): void;
}
```

**Issue 3: Slow Compilation**

```bash
# Diagnose slow compilation
tsc --diagnostics
tsc --extendedDiagnostics

# Solutions:
# 1. Enable incremental compilation
# 2. Use skipLibCheck
# 3. Split into project references
# 4. Use faster transpiler (esbuild/swc)
```

### Debugging Techniques

```typescript
// Use debugger statement
function complexFunction() {
  debugger;  // Pause execution here
  // ... complex logic
}

// Source map configuration
{
  "compilerOptions": {
    "sourceMap": true,
    "inlineSources": true
  }
}

// VS Code launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug TypeScript",
      "program": "${workspaceFolder}/src/index.ts",
      "preLaunchTask": "npm: build",
      "outFiles": ["${workspaceFolder}/dist/**/*.js"],
      "sourceMaps": true
    }
  ]
}
```

---

## Conclusion of Part 3

This concludes Part 3 of the TypeScript Mastery series covering the compiler and tooling ecosystem.

**What We've Covered:**

1. **Compiler Architecture** - Pipeline phases, compilation modes, Compiler API
2. **tsconfig.json** - Comprehensive configuration options and best practices
3. **Module Systems** - ESM, CommonJS, module resolution strategies
4. **Build Tools** - Integration with Webpack, Vite, esbuild
5. **Performance** - Compilation speed and bundle size optimization
6. **Testing** - Jest configuration and type testing
7. **Deployment** - Production builds, Docker, environment configuration
8. **Troubleshooting** - Common issues and debugging techniques

**Key Skills Acquired:**
- Understand TypeScript compiler internals
- Configure projects optimally
- Integrate with build tools
- Optimize compilation performance
- Deploy TypeScript applications
- Debug compilation issues
- Set up monorepos with project references

**What's Next:**

In **Part 4: TypeScript in Practice**, we'll explore:
- Real-world patterns and architectures
- Framework integration (React, Vue, Angular, Node.js)
- API development with TypeScript
- State management patterns
- Error handling strategies
- Testing strategies
- Performance optimization
- And much more!

Continue your journey to TypeScript mastery with Part 4!

---

**Total Word Count:** ~20,000 words

**Topics Covered:**
✅ TypeScript compiler architecture and phases
✅ Comprehensive tsconfig.json configuration
✅ Module systems and resolution
✅ Build tool integration (Webpack, Vite, esbuild)
✅ Performance optimization techniques
✅ Testing with Jest and type testing
✅ Production deployment strategies
✅ Troubleshooting and debugging
✅ 10+ FAQs with detailed answers
✅ 5+ Interview questions with solutions
✅ Real-world examples and configurations
✅ Best practices throughout